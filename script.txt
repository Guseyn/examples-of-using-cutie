Script:

Hi, it’s Guseyn. In this video I’ll demonstrate my solution for callback hell problem, which I’ve been using for last year. It’s based on ideas of declarative programming and pure object-oriented paradigm, which I really like. I’ll show why I don’t use Promises and async/await abstractions for resolving this particular problem, and why I think that declarative constructions is the only good way to write code in the asynchronous environment for big and complex applications. Also I’ll introduce you my library which provides such declarative abstractions.

Let’s take a look at this silly but quite representative  code where we make a sequence of async calls. Here we try to read some content from first file and write it into another file. Most people think that the main problem of using callback is that our code becomes nested, but in my opinion, the main problem of callbacks is that we expose results and behaviour outside of our async calls. Callbacks are kinda proxies which we use for data manipulation and error handling, also in callbacks we invokes other logic which can use other async calls, so we call call-backs inside of other callbacks, and as a result we get spaghetti code. So, basically we share this result here in callback, and here we use it as an argument in another async call. And the value of this result can mutate, so it  becomes more problematic to control data flow in our application.
Also you can see here duplication of code where check if error is null or not.

So, it’s clear that you cannot write big application using callbacks. Of course you cat structure yours code adding more grouping functions, but I don’t think that it’s a good approach, because eventually you will duplicate a lot of code, and  is not great.

Now we can look at promises abstraction which was introduced to solve the callback hell problem(maybe). So, what we do here: we just wrap our async functions with Promise objects where we put here result callback function and reject function which activates when an error occurs. But in my opinion it’s not better than just structuring you code by adding more functions, because as u can see, we still expose our data and error handling outside of async calls. Yes, of course now you can use chain of async calls instead of nested callback structure, but still it’s not great idea because it’s really difficult to structure code in such way, you should pay more and more attention to the data flow in your application, you still share it and value of it can be changed. Anyway, the idea of Promises looks ugly to me. I expected more than this stupid solution, but we have what we have.

And current trend is to use async/await abstraction. It’s just syntax sugar for Promises, and it works in the following way: async key word tell us that it’s async function and await key word says that we have to wait for the result from the async call. Again, it does not solve the problem, because we still need to expose data outside, you also need to make error handling and we still need to invoke dot then, because sometimes you cannot invoke several async functions by key word await, right. You need to know which async calls use result from another async calls. And it makes the whole situation even worse, because we remove async behaviour in our code, and still we need somehow to structure our code because it’s easy to make mistake. And we still have problems with error handling, we again expose it outside.

The main point of my concern is that people trying to solve callback hell problem using trasitional procedural programming, and in my opinion it's a bad desision to follow this way. So, what's my idea. If these things are not good, what can I suggest.

Well, let's take a look on this declarative constructions in this code. So, what's going on here? In this example we just use async objects like wrappers around async calls, and they the same number of arguments, in the same order like their corresponding async call. Just one thing, we don't use there callbacks. We use these objects as results for other async objects. Let's take a look on how they are designed from inside. We have so called abstraction AsyncObject, and all we need to create such wrapper around any async call is just to create a class that extends AsyncObject and overrides method asynCall. Also, we can do postprocessing via mwthod onResult, or just handle an error via method onError. And as you can see we encapsulate here behaviour about result and error, and our object represents the result itself in the context for other async objects. So, what other advantages of this approach? Well, you can reuse these async objects, because as you can see they are really small, they just wrap one async call and that's it, so it's easier to maintain them. Another thing is that you don't need to worry about synchronizing results from async calls in your code, because let's say we have some async object, and it will be invoked as soon as all arguments of the async objects are retrieved. Let's see how async call of ReadDataByPath is designed. As you can see, we just return function fs.readFile. In WrittenFile it's more complex, because method fs.writeFile does not have result in its callback, so we define what exactly we want this object to represent. In this case we want it to be a file, right? because it's called WrittenFile, file that has been written with some content. In the constructor here arguments can be either AsyncObject or simple data like strings, numbers, bollean values or event other complex objects and arrays. But we can guarantee that in this method we get all arguments as ready results from corresponding async calls. That's so easy.

Another thing is that you can make async object not only for async calls, but also for sync call. So, instead of overriding method asyncCall, you override instad method syncCall. Why do you need this? Well, the thing is that you cannot use async objects out of context async composition. You need to write you code completely in this decalrative way.

For example, you can parse json via ParsedJSON async object. [Show super nested flexible feature]

The beauty of this approach is that you can easily to test such declrartive code. I try to show it on example StrictEqualAssertion async object. [Show with different combinations of async objects]

You might ask how to create web applications with such approach. Well I created a library that can help you. It's called cutie-rest. And that's how you can do it. [show example]

You can also crate objects async-ly [show cutie-created]

Also I would like to show concept of reusing async compositions, or concept of sequnce of async compositions. For thins thing we use methods as and after. [Show example in cutie rest]

If we want to talk about disadvantages of this approach. I would emphasize 3 problems. First is that we need to write a lot of wrappers, but luckily I've written a lot of libraries for different modules in Node, and for different abstractions in JavaScript language, so you can use these libs. You can find them on my github account. I'll put all needed links in the description of the video. Another thing is performance. But I don't thing it's affected to much to worry about this thing. I think that maintainability is much more important than speed of code and performance. More over this approach force you to create strict structure, so it's really difficult to make mistakes that can cause you performance issues like using async/await abstractions where you can make such mistakes easily. More over, I think you agree with, that it's much easier to find problems with performance when you have well written and structured code than in case where you have big mess in your codebase. If creators of javascript engines would think in the direction of such declarative programming, we could improve performance with garbage collection and creating a lot of objects. And lastly, but not leastly it's cultural problem. People don't use to write code in such style, where you have big composition of objects. But that's the pure object oriented approach, and I really like it.

So, that's pretty much it what I wanted show. Thanks for watching, see you soon.


