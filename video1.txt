Hello everyone, it's Guseyn
This is an introductory video about my ideas on solving callback-hell problem and structuring code in the asynchronous environment. The solution I want to present to you is based on ideas of declarative programming and pure object-oriented paradigm, which I am big fan of.

So, in this video I'll show you how I see the callback-hell problem, I'll try to exaplain why I think that Promises and async/await abstraction don't really solve this particular problem. Also I will demonstrate why I think that declarative constructions is only good way to write complex asynchronous code for big applications. 

I'll make a little instroduction of my library cutie which provides such abstractions and how you can use them in your code. Also I'll talk a bit about downsides of my solution.

I just want to warn you that this is just first video in the series of videos about the approach that I want to show you, so the main point of this video is just to present you new idea which you might find useful and fun to use. If you want to learn more about this thing, you can wait for my next videos about this stuff or you can read more information in the links that I left in the description of this video.

Anyway, I think we can start.

// callback-example.js
Let's take a look at this silly but quite representative code, where we make a sequence of async calls. Here we try to read some content from this file and write this content into another file. Most people think that the main problem of using callbacks is that our code becomes more nested and that's why it's difficult to read such code. But I think this is not complete vision of the problem. The actual problem is that we we use callbacks as proxies between async calls. We exposde data and behaviour outside of async calls to callbacks where we do all the work: processing result with some logic, error handling, we share results that we get from callbacks as arguments for other async calls inside of these callbacks, and these results can mutate, so it becomes even more problematic to control data flow in our code. Also you can see duplication of code where we check if error is null or not. So, it's really diffucult to write more or less big programms using this approach and keep your code clean, readable and maintainable. Of course, you can structure your code adding functions which groups different combinations of async calls. But these functions are not so resusable, because all you do is just grouping different async call just to make you code shorter, but you cannot do it always. Anyway this approach is not efficient enough.

How can we solve callback problem?

Let's talk about Promises, which were introduced to do that. But I don't think they actually do. Let's take at the same logic but with using Promises. Promise is just an object that has one argument as a function with two arguments: resolve function and reject function. So when result from async call is ready we invoke resolve function, and when some error occurs we invoke reject function. Promises makes our code less nested, it's true: instead of complex callback structure we have a chain of asyn calls. But it does not solve other problems which I described. We still expose our data and behaviour outside of async calls to some function via .then. We still handle errors outside of our async calls and so on.

I think that people who created the concept of Promises understood that, and that's why asyn/await conception was introduced as syntax sugar for Promises. But the is that it made the whole situation even worse. They tried to imitate async code as synchronous code in the traditional procedural way. So, what are async/await key words mean. async is key word that says that the following function after this word is asynchronous, so it based on async calls. And await is used for waiting for the result from asyn function. And you have to use await in async function. And the problem of this conception is that we still try to write some combinations of async calls, we are tying somehow to group them, so we can write less neted code. But in fact we lose control of data flow in our code. We can get a result as it is, but we have to constantly keep in mind if some calls depend on each other because await key word blocks our thread in the async call where it's used. We don't want to have something that's called async/awit hell problem, right? It's when we invoke several async calls, which don't use each other results. But it's kinda easy to make such mistakes which broke the whole idea of asynchronous programming.
