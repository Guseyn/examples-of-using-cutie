Hello everyone, it's Guseyn
This is an introductory video about my ideas on solving callback-hell problem and structuring code in the asynchronous environment. The solution I want to present to you is based on ideas of declarative programming and pure object-oriented paradigm, which I am big fan of.

So, in this video I'll show you how I see the callback-hell problem, I'll try to exaplain why I think that Promises and async/await abstraction don't really solve this particular problem. Also I will demonstrate why I think that declarative constructions is only good way to write complex asynchronous code for big applications. 

I'll make a little instroduction of my library cutie which provides such abstractions and how you can use them in your code. Also I'll talk a bit about downsides of my solution.

I just want to warn you that this is just first video in the series of videos about the approach that I'll describe in this video, so the main point of this video is just to present you new idea which you might find useful and fun to use. If you want to learn more about this thing, you can wait for my next videos about this stuff or you can read more information in the links that I left in the description of this video.

Anyway, I think we can start.

// callback-example.js
Let's take a look at this silly but quite representative code, where we make a sequence of async calls. Here we try to read some content from this file and write this content into another file. Most people think that the main problem of using callbacks is that our code becomes more nested and that's why it's difficult to read such code. But I think this is not complete vision on this problem. The actual problem is that we we use callbacks as proxies between async calls. We exposde data and behaviour outside of async calls to callbacks where we do all the work: processing result with some logic, error handling, we share results that we get from callbacks as arguments for other async calls inside of these callbacks, and these results can mutate, so it becomes even more problematic to control data flow in our code. Also you can see duplication of code where we check if error is null or not. So, it's really diffucult to write more or less complex programms using this approach and keep your code clean, readable and maintainable. Of course, you can structure your code somehow adding functions which groups different combinations of async calls. But these functions are not so resusable, because all you do is just grouping different async calls just to make your code shorter, but you cannot do it always. Anyway this approach is not efficient enough.

How can we solve callback-hell problem then?

Let's talk about Promises, which were introduced to do that. But I don't think they actually do. Let's take look at the same logic but with using Promises. Promise is just an object that has one argument as a function with two arguments: resolve function and reject function. So when result from async call is ready we invoke resolve function, and when some error occurs we invoke reject function. Promises makes our code less nested, it's true: instead of complex callback structure we have a chain of asyn calls. But it does not solve other problems which I described. We still expose our data and behaviour outside of async calls to some function via .then. We still handle errors outside of our async calls and so on.

I think that people who created the concept of Promises understood that, and that's why asyn/await conception was introduced as syntax sugar for Promises. But the fact is that it made the whole situation even worse. They tried to imitate async code as synchronous code in the traditional procedural way. First, let me explain what are async/await key words mean. async is key word that says that the following function after this word is asynchronous, so it based on async calls. And await is used for waiting for the result from async function. And you must use await in async function. And the problem of this conception is that we still try to write some combinations of async calls, we are tying somehow to group them, so we can write less nested code. But in fact we lose control of data flow. We can get a result as it is, but we have to constantly keep in mind if some calls depend on each other or not because await key word blocks our thread in the async funtion where it's used. We don't want to have something like that's called async/awit hell problem, right? It's when we invoke several async calls, which don't use each other results. But it's kinda easy to make such mistakes which broke the whole idea of asynchronous programming.
Of course, you can use Promise.all() to prevent such things, but we back to using Promises, does it mean that idea and design of async/await is not efficient enough to completely avoiding Promises in our code. It seem it's not..
And we still have the problem with error handling. Of course, we can do via standart try/catch mechanism in JavaScript, but I don't think that such things like try/catch constructions make our code easier to read and maintain.

Another big problem which I can see is noisy words: Promise, async, await, .then, .catch, .all and other things. Are they related to the business logic? Is procedural approach is the best solution for solving mentioned problems? I don't thinks so.

Before presenting my solution, I want to show the difference between procedural and declarative programming on this simple example. Here we just try to get some user from database, build account for this user and save it. Simple logic, and the same thing in the declarative style would look smth like this. As you can see, the main of point of such delcarative style is that we hide logic inside of these objects and we represent what we want to see as result of our programm. And these objects are immutable, so we can easily test such code and control the state of these objects.

So, how can such declarative style help up solve callback hell problem. So, let's see. 
This is what I propose. We can present...

