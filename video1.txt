Hi, it's Guseyn
This is an introductory video about my ideas on solving callback-hell problem and structuring code in the asynchronous environment. The solution I want to present to you is based on ideas of declarative programming and pure object-oriented paradigm, which I am big fan of.

So, in this video I'll show you how I see the callback-hell problem, I'll try to exaplain why I think that Promises and async/await abstractions don't really solve this particular problem. Also I will demonstrate why I think that declarative constructions is the only good way to write complex asynchronous code for big applications. 

I'll make a little introduction of my library cutie which provides such abstractions and how you can use them in your code. Also I'll talk a bit about downsides of my solution.

I just want to warn you that this is just first video in the series of videos about the approach that I'll describe in this video, so the main point of this video is just to present you new idea which you might find useful and fun to use. If you want to learn more about this thing, you can wait for my next videos about this stuff or you can read more information in the links that I left in the description of this video.

Anyway, I think we can start.

// callback-example.js
Let's take a look at this silly but quite representative code, where we make a sequence of async calls. Here we try to read some content from this file and write this content into another one.

Most people think that the main issue of using callbacks is that our code becomes more nested, so it's difficult to read. But I think this is not complete vision on this problem. 

The thing is that we use callbacks as proxies between async calls. We exposde data and behaviour outside of async calls to callbacks where we do all the work: processing result with some logic, error handling, we share results that we get from callbacks as arguments for other async calls inside of these callbacks, and these results can mutate, so it becomes even more problematic to control data flow in our code. Also you can see duplication of code where we check if error is null or not. So, it's really diffucult to write more or less complex programms using this approach and keep your code clean, readable and maintainable. Of course, you can structure your code somehow adding functions which groups different combinations of async calls. But these functions are not so resusable, because all you do is just grouping different async calls just to make your code shorter, but you cannot do it always. Anyway this approach is not efficient enough.

How can we solve callback-hell problem then?

// promise-example.js
Let's talk about Promises, which were introduced to do that. But I don't think they actually do. Let's take look at the same logic but with using Promises. Promise is just an object that has one argument as a function with two arguments: resolve function and reject function. So when result from async call is ready we invoke resolve function, and when some error occurs we invoke reject function. Promises makes our code less nested, it's true: instead of complex callback structure we have a chain of asyn calls. But it does not solve other problems which I described. We still expose our data and behaviour outside of async calls to some function via .then. We still handle errors outside of our async calls and so on.

// async-await.
I think that people who created the concept of Promises understood that, and that's why asyn/await conception was introduced as syntax sugar for Promises. But the fact is that it made the whole situation even worse. They tried to imitate async code as synchronous code in the traditional procedural way. First, let me explain what are async/await key words mean. async is key word that says that the following function after this word is asynchronous, so it based on async calls. And await is used for waiting for the result from async function. And you must use await in async function. And the problem of this conception is that we still try to write some combinations of async calls, we are tying somehow to group them, so we can write less nested code. But in fact we lose control of data flow. We can get a result as it is, but we have to constantly keep in mind if some calls depend on each other or not because await key word blocks our thread in the async funtion where it's used. We don't want to have something like that's called async/awit hell problem, right? It's when we invoke several async calls, which don't use each other results. But it's kinda easy to make such mistakes which broke the whole idea of asynchronous programming.
Of course, you can use Promise.all() to prevent such things, but we back to using Promises, does it mean that idea and design of async/await is not efficient enough to completely avoiding Promises in our code. It seem it's not..
And we still have the problem with error handling. Of course, we can do via standart try/catch mechanism in JavaScript, but I don't think that such things like try/catch constructions make our code easier to read and maintain.

Another big problem which I can see is noisy words: Promise, async, await, .then, .catch, .all and other things. Are they related to the business logic? Is procedural approach is the best solution for solving mentioned problems? I don't thinks so.

Before presenting my solution, I want to show the difference between procedural and declarative programming on this simple example. Here we just try to get some user from database, build account for this user and save it. Simple logic, and the same thing in the declarative style would look smth like this. As you can see, the main of point of such delcarative style is that we hide logic inside of these objects and we represent what we want to see as result of our programm. And these objects are immutable, so we can easily test such code and control the state of these objects.

So, how can such declarative style help us solve callback hell problem. So, let's see. 
This is what I propose. We can present our program as a composition or as a tree where we can declare what we want to get as a result. In this example we have two async objects ReadDataByPath which encapsulate function fs.readFile, and WrittenFile which encapsulates async function fs.writeFile. ReadDataByPath represents some content from file, and WrittenFile represents a file(or a path to the file), which has been written with some content. And you can notice that these objects have the same arguments in the same order that thier corresponding async calls have. You might find it joyful to read such code: so, it's like we want to get file that has been written with some content that has been read from another file. I think that's the way we should write progams in general, not only in the asynchronous environments. But the whole power of this approach you can feel when we try to get rid of callbacks. And wonderful thing about async composition is that you can put arguments like eigher other async object or simple objects and primitives. For example, instead of this first argument we can put another async object ReadDataByPath that gets the path from some 3rd file. Isn't wonderful?

Let's take a quick look at how these async objects are designed from the inside. First let's see what happens in ReadDataByPath. We see here a class that extends AsyncObject that's provided by library cutie. And we create a constructure with arguments path (which can be eigher simple string or som other AsyncObject) and options object (which also can be as a simple object or some AsyncObject that represents options object). Also we declare here our asyn call, which is fs.read. You can encapsulate in Async object not only asyn call, but sync call. But it will still async object because it can has async objects as arguments, so it can rely on other async objects, and this is makes it async object. We will talk about this in more details in the next video, but you can also read stuff about this in the links in the description of this video.

Anyway, let take a look at WrittenFile. It's a bit more complex, but still we have constructor where invoke super constructor with the same arguments as for fs.writeFile except callback, obviously. And as fs.writeFile does not have any result in the callback as you remember, we define it in our custom async call which encapsulate original async call where we declare what we want to save as a result. In this case we want to save a file as a path. By the way, as I saild, in the constructor we can put eigher async objects as arguments or simple objects and primitive. But here in the declaration of our method asyncCall() we have ready results which we can use for our asyn call fs.writeFile. And we have method onResult where we can return the file which we defined here.

// open cutie-example
So, why basically this approach solves all the problems which I described?

// open ReadDataByPath again
First of all, we encapsulate all the here, in the object. Async object has methods onResult and onError which you can override and make processing result or handle error. For example, in onResult you can do smth like this. ... and in onError you can for example log your error and then throw it. By default this method just throws error. There are other stuff you can do here, for example you can declare that you don't want your program to stop event if something fails, you specify if your callback has an error argument or not and a lot of other stuff which I will cover in next videos.

// open cutie-example
Another thing that I want to mention you async objects work only in the context of other async aobject in the async composition, so your whole program would be declarative, which is in my opinion is great.

But obviously, there are some problems with this approach. First is that you have to write a lot of such declarative wrapper around static functions in Node. But I solved a bit this problem, I created a lot of libs like cutie-fs, cutie-http, cutie-https, cutie-buffer, cutie-json, cutie-stream, and even cutie-rest. I will put link to my github account, so you can find all those libs. Another thing is that people don't use to write and read such code. They think that it's too verbose and weird. But in my opinion, it's just a cultural problem, because I really feel that this code, that I want to maintain and read, and we have well written structured code. And lastly, but not leastly it's performance. As you can imagine that in this approach we have to create a lot of objects, and it can be not good for garbage collection and stuff like that. But in my experince, performance is not affected to much that I give up this idea and move to traditional procedural programming. And I think that it's better have clean code instead of fast code, because it would be easier to find performance issues in the code that you can understand than in the bad structured code. And more over I think that it's possible to create a conventor that translate such declarative code into procedural code as exectuable file that you can run in production environment, for example. So.. yeah

That's pretty much it what I wanted to share in this video. Thank you for watching. See you soon.
